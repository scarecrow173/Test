//=======================================================================================
//!	@file	:	MyMath.cpp
//!	@brief	:	MyMath関数定義
//!	@author	:	小山 瑛圭
//!	@date	:	2014/5/01
//!	@par	:	算術系
//!	@note	:	example
//=======================================================================================

#include "MyMath.h"
namespace AK
{
namespace Math
{
//=======================================================================================
//		Constants Definitions
//=======================================================================================
//=======================================================================================
//		public method
//=======================================================================================
//-------------------------------------------------------------
//!	@brief		: サイン
//!	@param[in]	: ラジアン値(F32)
//!	@return		: サイン値
//-------------------------------------------------------------
F32 Sin( F32 rad )
{
	return sinf(rad);
}
//-------------------------------------------------------------
//!	@brief		: コサイン
//!	@param[in]	: ラジアン値(F32)
//!	@return		: コサイン値
//-------------------------------------------------------------
F32 Cos( F32 rad )
{
	return cosf(rad);
}
//-------------------------------------------------------------
//!	@brief		: タンジェント
//!	@param[in]	: ラジアン値(F32)
//!	@return		: タンジェント値
//-------------------------------------------------------------
F32 Tan( F32 rad )
{
	return tanf(rad);
}
//-------------------------------------------------------------
//!	@brief		: アークサイン
//!	@param[in]	: サイン値
//!	@return		: アークサイン値
//-------------------------------------------------------------
F32 ArcSin( F32 val )
{
	if( val >= 1.f )
		val = 1.f - F32_MIN;
	if( val <= 0.f )
		val = 0 + F32_MIN;
	return asinf( val );
}
//-------------------------------------------------------------
//!	@brief		: アークコサイン
//!	@param[in]	: コサイン値
//!	@return		: アークコサイン値
//-------------------------------------------------------------
F32 ArcCos( F32 val )
{
	if (val >= 1.f)
		val = 1.f - F32_MIN;
	if (val <= 0.f)
		val = 0.f + F32_MIN;
	return acosf(val);
}
//-------------------------------------------------------------
//!	@brief		: アークタンジェント
//!	@param[in]	: タンジェント値
//!	@return		: アークタンジェント値
//-------------------------------------------------------------
F32 ArcTan( F32 val)
{
	return atanf(val);
}
//-------------------------------------------------------------
//!	@brief		: a/bのアークタンジェント値
//!	@param[in]	: a
//!	@param[in]	: b
//!	@return		: アークタンジェント値
//-------------------------------------------------------------
F32 ArcTan2( F32 a, F32 b)
{
	return atan2f(a, b);
}
//-------------------------------------------------------------
//!	@brief		: 累乗
//!	@param[in]	: 累乗したい値
//!	@param[in]	: 乗数
//!	@return		: valをexponent乗した値
//-------------------------------------------------------------
//  累乗( aのb乗 )
F32 Pow( F32 val, F32 exponent)
{
	return powf(val, exponent);
}
//-------------------------------------------------------------
//!	@brief		: 2を底とする対数
//!	@param[in]	: example
//!	@return		: example
//-------------------------------------------------------------
F32 Log2( F32 val)
{
	F32 ex = logf(val);
	static const F32 rcpLogE2 = 1.4426950408889634073599246810019f;
	return ex * rcpLogE2;
}
//-------------------------------------------------------------
//!	@brief		: 10を底とする対数
//-------------------------------------------------------------
F32 Log10( F32 val)
{
	return log10f(val);
}
//-------------------------------------------------------------
//!	@brief		: 平方根
//-------------------------------------------------------------
F32 Sqrt( F32 val)
{
	assert(val >= 0);
	return sqrtf(val);
}
//-------------------------------------------------------------
//!	@brief		: 非数チェック
//-------------------------------------------------------------
bool isNaN( F32 val)
{
	return (val != val);
}
//-------------------------------------------------------------
//!	@brief		: DegreeをRadianへ
//!	@param[in]	: Degree
//!	@return		: Radian
//-------------------------------------------------------------
F32 DegToRad(F32 deg)
{
	return deg * TO_RAD;
}
//-------------------------------------------------------------
//!	@brief		: RadianをDegreeへ
//!	@param[in]	: Radian
//!	@return		: Degree
//-------------------------------------------------------------
F32 RadToDeg(F32 rad)
{
	return rad * TO_DEG;
}
//-------------------------------------------------------------
//!	@brief		: 角の正規化
//!	@param[in]	: Radian
//!	@return		: 正規化された角(ラジアン値)
//-------------------------------------------------------------
//  角度正規化
F32 AngleNormalize( F32 rad )
{
	while (rad > PI)	rad -= PI2;
	while (rad < -PI)	rad += PI2;
	return rad;
}
//-------------------------------------------------------------
//!	@brief		: 指定の数よりも大きい2のべき乗の値を取得(4000万以上の値は無効)
//!	@param[in]	: 値(この値より大きい2のべき乗を求める)
//!	@return		: 指定の数よりも大きい2のべき乗
//-------------------------------------------------------------
S32 PowerofTwo( S32 num )
{
	S32 r = 1;
	while (r < num) r = r << 1;
	return r;
}
//-------------------------------------------------------------
//!	@brief		: 値が2の乗数かどうかチェック
//!	@param[in]	: チェックしたい値
//!	@return		: 2のべき乗であればtrue
//-------------------------------------------------------------
bool isPowerofTwo( S32 num )
{
	if( num == 0 ) return false;
	return (num & (num - 1)) == 0;
}
//-------------------------------------------------------------
//!	@brief		: スクリーン座標をワールド座標へ変換
//!	@param[in]	: スクリーン座標
//!	@param[in]	: 変換後のZ
//!	@param[in]	: スクリーンの幅
//!	@param[in]	: スクリーンの高さ
//!	@param[in]	: ビュー行列
//!	@param[in]	: プロジェクション行列
//!	@return		: ワールド座標
//-------------------------------------------------------------
Vector3 ScreenToWorld(const Vector2 pos, F32 z, F32 screenWidth, F32 screenHeight, const Matrix& view, const Matrix& proj)
{
	Vector3 out;
	Matrix invView = view;
	Matrix invProj = proj;
	
	D3DXMatrixInverse(&invView, NULL, &invView);
	D3DXMatrixInverse(&invProj, NULL, &invProj);

	Matrix invVp;

	D3DXMatrixIdentity(&invVp);

	invVp._11 = screenWidth * 0.5f;
	invVp._22 = -screenHeight * 0.5f;
	invVp._41 = screenWidth * 0.5f;
	invVp._42 = screenHeight * 0.5f;
	

	D3DXMatrixInverse(&invVp, NULL, &invVp);

	Matrix transform = invVp * invProj * invView;
	D3DXVec3TransformCoord(&out, &Vector3(pos.x, pos.y, z), &transform);
	return out;

}
//-------------------------------------------------------------
//!	@brief		: ワールド座標をスクリーン座標へ変換
//!	@param[in]	: ワールド座標
//!	@param[in]	: スクリーンの幅
//!	@param[in]	: スクリーンの高さ
//!	@param[in]	: ビュー * プロジェクション
//!	@return		: スクリーン座標
//-------------------------------------------------------------
Vector2 WorldToScreen(const Vector3 pos, S32 screenWidth, S32 screenHeight, const Matrix& viewProj)
{
	Vector2 out;
	//  ビュー&投影行列で変換
	out.x = pos.x * viewProj._11 + pos.y * viewProj._21 + pos.z * viewProj._31 + viewProj._41;
	out.y = pos.x * viewProj._12 + pos.y * viewProj._22 + pos.z * viewProj._32 + viewProj._42;
	F32 w = pos.x * viewProj._14 + pos.y * viewProj._24 + pos.z * viewProj._34 + viewProj._44;
	
	F32 width = screenWidth * 0.5f;
	F32 height = screenHeight * 0.5f;
	
	//  スクリーンに変換
	out.x /= w;
	out.y /= w;
	
	out.x = out.x * width + width ;
	out.y = -out.y * height - height;
	
	out.x += 0.5f;
	out.y += 0.5f;
	
	//  Z値出力
	//if( outZ )
	//{
	//    *outZ = pos.x * matViewProj._13 + pos.y * matViewProj._23 + pos.z * matViewProj._33 + matViewProj._43;
	//}
	
	return out;
}
//-------------------------------------------------------------
//!	@brief		: example
//!	@param[in]	: example
//!	@return		: example
//-------------------------------------------------------------

//=======================================================================================
//		protected method
//=======================================================================================

//=======================================================================================
//		private method
//=======================================================================================
};
};
//===============================================================
//	End of File
//===============================================================
